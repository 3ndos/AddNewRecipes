using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace AddNewRecipes
{
    public class Program
    {
        static Lazy<Settings> LazySettings = new Lazy<Settings>();
        public static Settings Settings => LazySettings.Value;
        public static HashSet<string>? ContainerEditorIDs { get; set; } = null!;
        public static Task<int> Main(string[] args)
        {
            return SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch).SetAutogeneratedSettings("Settings", "settings.json", out LazySettings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "AddNewRecipes.esp")
                .Run(args);
        }
        private static string[] BadKeywords = { "MagicAlchHarmful" };
        public static List<IngredientCombination> Combinations = new List<IngredientCombination>();
        public static Mutex OurMutex = new Mutex(), OurMutex2 = new Mutex();
        private static int Percent;
        public static bool FinishedProcessing;
        public static uint PotionRecipeCount, PoisonRecipeCount, ImpurepotionRecipeCount;
        public static int ReportedCount = -1, TotalProcessedCount = 0, TotalIngredientCount = 0;
        public static IEnumerable<IIngredientGetter>? AllIngredients;
        public static Stopwatch StopWatch = new Stopwatch();
        public static IEnumerable<IFormLink<IKeyword>>? BadKeywordsF;
        public static Settings? Config = new Settings();
        const uint LeveledListSize = 255;
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            try
            {
                //Reading the Settings from the settings.json file
                var content = File.ReadAllText(state.RetrieveConfigFile("settings.json"));
                Config = JsonConvert.DeserializeObject<Settings>(content, new JsonSerializerSettings
                {
                    NullValueHandling = NullValueHandling.Ignore
                })!;
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine("Cannot find settings file, using default values.");
            }

            ModKey[] modkeys = new ModKey[(int)Config?.ESPCount!];
            SkyrimMod[] mods = new SkyrimMod[(int)Config?.ESPCount!];
            for (int u = 0; u < Config?.ESPCount; u++)
            {
                modkeys[u] = new ModKey("AddNewRecipes-" + u, ModType.Plugin);
                mods[u] = new SkyrimMod(modkeys[u], SkyrimRelease.SkyrimSE);
            }
            ContainerEditorIDs = new HashSet<string>(Config?.ContainerEditorIds!);
            BadKeywordsF = (from keyword in state.LoadOrder.PriorityOrder.OnlyEnabled().Keyword().WinningOverrides() where BadKeywords.Contains(keyword.EditorID) select (IFormLink<IKeyword>)(new FormLink<IKeyword>(keyword.FormKey))).ToList();
            IEnumerable<IIngredientGetter> ingredients = state.LoadOrder.PriorityOrder.OnlyEnabled().Ingredient().WinningOverrides().Where(x => !Config?.SkipPlugins.Contains(x.FormKey.ModKey.Name.ToLower()) == true).Where(x => (!Config?.SkipIngredients.Intersect(x.Name?.ToString()?.Split()!).Any() == true || Config?.SkipIngredients.Contains(x.Name?.ToString()!) == true)).Where(x => !String.IsNullOrEmpty(x.EditorID)).ToList();
            AllIngredients = ingredients;
            Percent = (int)(ingredients.Count() * Config?.OutputPercentage!);
            TotalIngredientCount = ingredients.Count();
            Thread[] threads = new Thread[(int)Config?.WorkerThreadCount!];
            int partitionsize = (ingredients.Count() / (int)Config?.WorkerThreadCount!);
            /* Split ingredient list evenly across threads */
            IEnumerable<IIngredientGetter>[] ingredientsL = ingredients.Partition(partitionsize).ToArray();
            /* If there is a remainder add it to last thread */
            if (ingredientsL.Length > Config.WorkerThreadCount)
            {
                ingredientsL[ingredientsL.Length - 2] = ingredientsL[ingredientsL.Length - 2].Concat(ingredientsL[ingredientsL.Length - 1]);
            }
            StopWatch.Start();
            Console.WriteLine("Using " + Config?.WorkerThreadCount + " threads to handle " + partitionsize + " ingredients each.");
            int startIndex = 0;
            for (int u = 0; u < Config?.WorkerThreadCount; u++)
            {
                ListProcessor lp = new ListProcessor(u, state, ingredientsL[u], startIndex);
                threads[u] = new Thread(new ThreadStart(lp.run));
                threads[u].Start();
                startIndex += partitionsize;
            }
            while (!FinishedProcessing)
            {
                if (TotalProcessedCount % Percent == 0)
                {
                    if (ReportedCount != TotalProcessedCount)
                    {
                        Console.WriteLine(TotalProcessedCount + " out of " + ingredients.Count() + " ingredients processed.");
                        StopWatch.Stop();
                        Console.WriteLine("time elapsed:  " + StopWatch.Elapsed.TotalSeconds + " seconds");
                        StopWatch.Reset();
                        StopWatch.Start();
                        ReportedCount = TotalProcessedCount;
                    }
                }
                Thread.Sleep(100);
            };
            Console.WriteLine("Terminating Threads.");
            for (int u = 0; u < Config?.WorkerThreadCount; u++)
                threads[u].Join();
            int RecipeMakeCount = 0, splitIndex = Combinations.Count / (int)Config?.ESPCount!, splitIndexCount = 0;
            if (Config?.RandomizeList == true)
            {
                Console.WriteLine("Randomizing Recipe List.");
                Combinations.Shuffle();
            }
            if (Config?.RecipePercentage < 100)
            {
                int count = Combinations.Count;
                int percentOfCombinations = (int)(count * (double)(0.01 * Config?.RecipePercentage!));
                Combinations.RemoveRange(percentOfCombinations, count - percentOfCombinations);
                Percent = (int)(Combinations.Count * Config?.OutputPercentage!);
                splitIndex = Combinations.Count / (int)Config?.ESPCount!;
                Console.WriteLine("Reducing recipe list by " + Config?.RecipePercentage + "% ...");
                Console.WriteLine(Config?.RecipePercentage! + "% of " + count + " is " + Combinations.Count);
            }
            Dictionary<string, int> nameCreateCache = new Dictionary<string, int>();
            uint newListCount = 0, newPotionRecipeCount = 0, newPoisonRecipeCount = 0, newImpurepotionRecipeCount = 0;
            List<IngredientCombination> tempCombinations = new List<IngredientCombination>();
            foreach (IngredientCombination ic in Combinations)
            {
                string? name = "";
                foreach (string? s in ic.MyEffects!)
                    name += s;
                name = name.Replace(" ", string.Empty);
                int nameIndex = 0;
                if (nameCreateCache.TryGetValue(name, out nameIndex))
                {
                    if (nameIndex <= Config?.MaxPotionTypeCount)
                    {
                        tempCombinations.Add(ic);
                        newListCount++;
                        switch(ic.Type)
                        {
                            case 0:
                                newPotionRecipeCount++;
                                break;
                            case 1:
                                newPoisonRecipeCount++;
                                break;
                            case 2:
                                newImpurepotionRecipeCount++;
                                break;
                        }
                    }
                    nameCreateCache[name] = nameIndex + 1;
                }
                else
                    nameCreateCache.Add(name, 0);
            }
            if (tempCombinations.Count != Combinations.Count)
            {
                Console.WriteLine("Combinations reduced to " + newListCount + " because of Max Potion Type Count of " + Config?.MaxPotionTypeCount);
                Combinations = tempCombinations;
                PotionRecipeCount = newPotionRecipeCount;
                PoisonRecipeCount = newPoisonRecipeCount;
                ImpurepotionRecipeCount = newImpurepotionRecipeCount;
            }
            Console.WriteLine("Creating Leveled lists...");
            IEnumerable<IBookGetter> books = from book in state.LoadOrder.PriorityOrder.Book().WinningOverrides() where book.FormKey.Equals(new FormKey(new ModKey("Skyrim", ModType.Master), 0x0F5CB1)) select book;
            IBookGetter noteTemplate = books.ToList()[0];
            Console.WriteLine("Processing " + Combinations.Count + " recipes.");
            Percent = (int)(Combinations.Count * Config?.OutputPercentage!);
            int i = 0;
            /* Main leveled list that gets added to recipe drop */
            LeveledItem[] mainpotionRecipeLVLI = new LeveledItem[mods.Length];
            LeveledItemEntry[] mainpotionRecipeLVLIentry = new LeveledItemEntry[mods.Length];
            LeveledItemEntryData[] mainpotionRecipeLVLIentrydata = new LeveledItemEntryData[mods.Length];
            for (int k = 0; k < mods.Length; k++)
            {
                mainpotionRecipeLVLI[k] = mods[k].LeveledItems.AddNew();
                mainpotionRecipeLVLIentry[k] = new LeveledItemEntry();
                mainpotionRecipeLVLI[k].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                mainpotionRecipeLVLIentrydata[k] = new LeveledItemEntryData();
                GlobalInt mainpotionGlobal = new GlobalInt(mods[k].GetNextFormKey(), SkyrimRelease.SkyrimSE);
                mainpotionGlobal.Data = new Random().Next((int)Config?.MinChance!, (int)Config?.MaxChance!);
                mods[k].Globals.Set(mainpotionGlobal);
                mainpotionRecipeLVLI[k].Global = new FormLinkNullable<IGlobalIntGetter>(mainpotionGlobal);
                mainpotionRecipeLVLI[k].EditorID = "mainpotionRecipeList" + k;
            }
            /* Must split sub leveled lists because it can only hold 255 items */
            uint[] potionRecipeListCount = new uint[mods.Length];
            uint[] poisonRecipeListCount = new uint[mods.Length];
            uint[] impurepotionRecipeListCount = new uint[mods.Length];
            uint[] masterpotionRecipeListCount = new uint[mods.Length];
            uint[] potionIndex = new uint[mods.Length], poisonIndex = new uint[mods.Length], impurepotionIndex = new uint[mods.Length];
            List<GlobalInt[]> potionGlobals = new List<GlobalInt[]>();
            List<LeveledItem[]> potionRecipeLVLIs = new List<LeveledItem[]>();
            List<LeveledItem[]> masterpotionRecipeLVLIs = new List<LeveledItem[]>();
            List<LeveledItemEntry[]> masterpotionRecipeLVLIentries = new List<LeveledItemEntry[]>();
            List<LeveledItemEntryData[]> masterpotionRecipeLVLIentriesdata = new List<LeveledItemEntryData[]>();
            List<GlobalInt[]> masterpotionGlobals = new List<GlobalInt[]>();
            List<LeveledItemEntry[]> potionRecipeLVLIentries = new List<LeveledItemEntry[]>();
            List<LeveledItemEntryData[]> potionRecipeLVLIentriesdata = new List<LeveledItemEntryData[]>(); ;
            List<LeveledItem[]> poisonRecipeLVLIs = new List<LeveledItem[]>();
            List<LeveledItemEntry[]> poisonRecipeLVLIentries = new List<LeveledItemEntry[]>();
            List<LeveledItemEntryData[]> poisonRecipeLVLIentriesdata = new List<LeveledItemEntryData[]>();
            List<GlobalInt[]> poisonGlobals = new List<GlobalInt[]>();
            List<LeveledItem[]> impurepotionRecipeLVLIs = new List<LeveledItem[]>();
            List<LeveledItemEntry[]> impurepotionRecipeLVLIentries = new List<LeveledItemEntry[]>();
            List<LeveledItemEntryData[]> impurepotionRecipeLVLIentriesdata = new List<LeveledItemEntryData[]>();
            List<GlobalInt[]> impurepotionGlobals = new List<GlobalInt[]>();
            for (int j = 0; j < mods.Length; j++)
            {
                potionRecipeListCount[j] = PotionRecipeCount / LeveledListSize + 1;
                poisonRecipeListCount[j] = PoisonRecipeCount / LeveledListSize + 1;
                impurepotionRecipeListCount[j] = ImpurepotionRecipeCount / LeveledListSize + 1;
                potionGlobals.Add(new GlobalInt[potionRecipeListCount[j]]);
                potionRecipeLVLIs.Add(new LeveledItem[potionRecipeListCount[j]]);
                masterpotionRecipeListCount[j] = ((((potionRecipeListCount[j] + poisonRecipeListCount[j] + impurepotionRecipeListCount[j])) / LeveledListSize) + 1);
                masterpotionRecipeLVLIs.Add(new LeveledItem[masterpotionRecipeListCount[j]]);
                masterpotionRecipeLVLIentries.Add(new LeveledItemEntry[masterpotionRecipeListCount[j]]);
                masterpotionRecipeLVLIentriesdata.Add(new LeveledItemEntryData[masterpotionRecipeListCount[j]]);
                masterpotionGlobals.Add(new GlobalInt[masterpotionRecipeListCount[j]]);
                potionRecipeLVLIentries.Add(new LeveledItemEntry[potionRecipeListCount[j]]);
                potionRecipeLVLIentriesdata.Add(new LeveledItemEntryData[potionRecipeListCount[j]]);
                for (int k = 0; k < masterpotionRecipeListCount[j]; k++)
                {

                    LeveledItemEntry entry = new LeveledItemEntry();
                    LeveledItemEntryData entrydata = new LeveledItemEntryData();
                    LeveledItem LVLI = mods[j].LeveledItems.AddNew();
                    LVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                    GlobalInt globalint = new GlobalInt(mods[j].GetNextFormKey(), SkyrimRelease.SkyrimSE);
                    globalint.Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                    mods[j].Globals.Set(globalint);
                    LVLI.Global = new FormLinkNullable<IGlobalIntGetter>(globalint);
                    LVLI.EditorID = "masterpotionRecipeList" + j + "-" + k;
                    entrydata.Reference = new FormLink<ILeveledItem>(LVLI.FormKey);
                    entrydata.Level = 1;
                    entrydata.Count = 1;
                    masterpotionRecipeLVLIentries.ElementAt(j)[k] = entry;
                    masterpotionRecipeLVLIentriesdata.ElementAt(j)[k] = entrydata;
                    masterpotionGlobals.ElementAt(j)[k] = globalint;
                    masterpotionRecipeLVLIs.ElementAt(j)[k] = (LVLI);
                }
                for (int l = 0; l < potionRecipeListCount[j]; l++)
                {
                    potionRecipeLVLIentries.ElementAt(j)[l] = new LeveledItemEntry();
                    potionRecipeLVLIentriesdata.ElementAt(j)[l] = new LeveledItemEntryData();
                    potionRecipeLVLIs.ElementAt(j)[l] = mods[j].LeveledItems.AddNew();
                    potionRecipeLVLIs.ElementAt(j)[l].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                    potionGlobals.ElementAt(j)[l] = new GlobalInt(mods[j].GetNextFormKey(), SkyrimRelease.SkyrimSE);
                    potionGlobals.ElementAt(j)[l].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                    mods[j].Globals.Set(potionGlobals.ElementAt(j)[l]);
                    potionRecipeLVLIs.ElementAt(j)[l].Global = new FormLinkNullable<IGlobalIntGetter>(potionGlobals.ElementAt(j)[l]);
                    potionRecipeLVLIs.ElementAt(j)[l].EditorID = "potionRecipeList" + j + "-" + l;
                    potionRecipeLVLIentriesdata.ElementAt(j)[l].Reference = new FormLink<ILeveledItem>(potionRecipeLVLIs.ElementAt(j)[l].FormKey);
                    potionRecipeLVLIentriesdata.ElementAt(j)[l].Level = 1;
                    potionRecipeLVLIentriesdata.ElementAt(j)[l].Count = 1;
                }
                poisonRecipeLVLIs.Add(new LeveledItem[poisonRecipeListCount[j]]);
                poisonRecipeLVLIentries.Add(new LeveledItemEntry[poisonRecipeListCount[j]]);
                poisonRecipeLVLIentriesdata.Add(new LeveledItemEntryData[poisonRecipeListCount[j]]);
                poisonGlobals.Add(new GlobalInt[poisonRecipeListCount[j]]);
                for (int l = 0; l < poisonRecipeListCount[j]; l++)
                {
                    poisonRecipeLVLIentries.ElementAt(j)[l] = new LeveledItemEntry();
                    poisonRecipeLVLIentriesdata.ElementAt(j)[l] = new LeveledItemEntryData();
                    poisonRecipeLVLIs.ElementAt(j)[l] = mods[j].LeveledItems.AddNew();
                    poisonRecipeLVLIs.ElementAt(j)[l].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                    poisonGlobals.ElementAt(j)[l] = new GlobalInt(mods[j].GetNextFormKey(), SkyrimRelease.SkyrimSE);
                    poisonGlobals.ElementAt(j)[l].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                    mods[j].Globals.Set(poisonGlobals.ElementAt(j)[l]);
                    poisonRecipeLVLIs.ElementAt(j)[l].Global = new FormLinkNullable<IGlobalIntGetter>(poisonGlobals.ElementAt(j)[l]);
                    poisonRecipeLVLIs.ElementAt(j)[l].EditorID = "poisonRecipeList" + j + "-" + l; ;
                    poisonRecipeLVLIentriesdata.ElementAt(j)[l].Reference = new FormLink<ILeveledItem>(poisonRecipeLVLIs.ElementAt(j)[l].FormKey);
                    poisonRecipeLVLIentriesdata.ElementAt(j)[l].Level = 1;
                    poisonRecipeLVLIentriesdata.ElementAt(j)[l].Count = 1;
                }
                impurepotionRecipeLVLIs.Add(new LeveledItem[impurepotionRecipeListCount[j]]);
                impurepotionRecipeLVLIentries.Add(new LeveledItemEntry[impurepotionRecipeListCount[j]]);
                impurepotionRecipeLVLIentriesdata.Add(new LeveledItemEntryData[impurepotionRecipeListCount[j]]);
                impurepotionGlobals.Add(new GlobalInt[impurepotionRecipeListCount[j]]);
                for (int l = 0; l < impurepotionRecipeListCount[j]; l++)
                {
                    impurepotionRecipeLVLIentries.ElementAt(j)[l] = new LeveledItemEntry();
                    impurepotionRecipeLVLIentriesdata.ElementAt(j)[l] = new LeveledItemEntryData();
                    impurepotionRecipeLVLIs.ElementAt(j)[l] = mods[j].LeveledItems.AddNew();
                    impurepotionRecipeLVLIs.ElementAt(j)[l].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                    impurepotionGlobals.ElementAt(j)[l] = new GlobalInt(mods[j].GetNextFormKey(), SkyrimRelease.SkyrimSE);
                    impurepotionGlobals.ElementAt(j)[l].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                    mods[j].Globals.Set(impurepotionGlobals.ElementAt(j)[l]);
                    impurepotionRecipeLVLIs.ElementAt(j)[l].Global = new FormLinkNullable<IGlobalIntGetter>(impurepotionGlobals.ElementAt(j)[l]);
                    impurepotionRecipeLVLIs.ElementAt(j)[l].EditorID = "impurepotionRecipeList" + j + "-" + l; ;
                    impurepotionRecipeLVLIentriesdata.ElementAt(j)[l].Reference = new FormLink<ILeveledItem>(impurepotionRecipeLVLIs.ElementAt(j)[l].FormKey);
                    impurepotionRecipeLVLIentriesdata.ElementAt(j)[l].Level = 1;
                    impurepotionRecipeLVLIentriesdata.ElementAt(j)[l].Count = 1;
                }
                Console.WriteLine("Splitting potions into lists (" + potionRecipeListCount[j] + " " + poisonRecipeListCount[j] + " " + impurepotionRecipeListCount[j] + ")");
            }
            Dictionary<string, int> nameCache = new Dictionary<string, int>();
            foreach (IngredientCombination ic in Combinations)
            {
                if (i % Percent == 0)
                    Console.WriteLine(i + " out of " + Combinations.Count + " recipes processed.");
                IBook newRecipe = noteTemplate.DeepCopy();
                RecipeMakeCount++;
                if (RecipeMakeCount > (splitIndex + splitIndexCount))
                    splitIndexCount += splitIndex;
                int modIndex = splitIndexCount / splitIndex;
                if (modIndex > Config?.ESPCount - 1)
                    modIndex = ((int)Config?.ESPCount!) - 1;
                newRecipe.FormKey = mods[modIndex].GetNextFormKey();
                string prefix = "[Potion]";
                if (ic.Type == 1)
                    prefix = "[Poison]";
                if (ic.Type == 2)
                    prefix = "[Impure Potion]";
                newRecipe.Description = prefix + ic.RecipeName;
                newRecipe.Name = ic.RecipeName;
                newRecipe.BookText = ic.PotionString;
                newRecipe.Weight = (float)Config?.RecipeWeight!;
                newRecipe.Value = (uint)Config?.RecipeValue!;
                string? name = "recipeof";
                foreach (string? s in ic.MyEffects!)
                    name += s;
                name = name.Replace(" ", string.Empty);
                int nameIndex = 0;
                if (nameCache.TryGetValue(name, out nameIndex))
                {
                    nameCache[name] = nameIndex + 1;
                    name = name + nameCache[name];
                }
                else
                {
                    nameCache.Add(name, 0);
                    name = name + "0";
                }
                newRecipe.EditorID = name;
                /* Add ingredients to CACO learning recipe script */
                if (state.LoadOrder.ContainsKey(ModKey.FromNameAndExtension("Complete Alchemy & Cooking Overhaul.esp")))
                {
                    string[] s = (from scriptentry in newRecipe.VirtualMachineAdapter?.Scripts where scriptentry.Name.Equals("CACO_AlchemyRecipeScript") select scriptentry.Name).ToArray();
                    if (s.Length < 1 && (Config?.LearnEffectsFromRecipe == true))//For adding recipe to a brand new item (not a copy of a vanilla recipe)
                    {
                        ScriptEntry cacoscript = new ScriptEntry();
                        cacoscript.Name = "CACO_AlchemyRecipeScript";
                        newRecipe.VirtualMachineAdapter?.Scripts.Add(cacoscript);
                    }
                    if (newRecipe.VirtualMachineAdapter?.Scripts != null)//For modiying a copy of a vanilla recipe modified by CACO(default)
                    {

                        for (int e = 0; e < newRecipe.VirtualMachineAdapter?.Scripts!.Count; e++)
                        {
                            ScriptEntry? se = newRecipe.VirtualMachineAdapter?.Scripts!.ElementAt(e);
                            if (se == null)
                                continue;
                            if (se.Name.Equals("CACO_AlchemyRecipeScript"))
                            {
                                if (Config?.LearnEffectsFromRecipe == false)
                                {
                                    newRecipe.VirtualMachineAdapter?.Scripts?.Remove(se);
                                    continue;
                                }
                                int[,] ingredientEffectIndex = new int[3, 4];
                                for (int m = 0; m < ingredientEffectIndex.GetLength(0); m++)
                                    for (int n = 0; n < ingredientEffectIndex.GetLength(1); n++)
                                        ingredientEffectIndex[m, n] = -1;
                                for (int m = 0; m < ic.MyIngredients.Length; m++)
                                {
                                    int offset = 0;
                                    for (int n = 0; n < ic.MyIngredients[m].Effects.Count; n++)
                                    {
                                        foreach (FormKey mgefformkey in ic.MyEffectsKeys!)
                                        {
                                            if (ic.MyIngredients[m].Effects[n] == null)
                                                continue;
                                            if (ic.MyIngredients[m].Effects[n].BaseEffect.FormKey.Equals(mgefformkey))
                                            {
                                                ingredientEffectIndex[m, offset++] = n;
                                            }
                                        }
                                    }

                                }
                                bool[,] ingredientEffectExist = new bool[3, 4];
                                bool[] ingredientExist = new bool[3];
                                bool thisRecipeExists = false, noValueAfterReadExists = false, alchemyRecipesReadExists = false;
                                for (int d = 0; d < se.Properties.Count; d++)//Scan CACO learning script properties
                                {
                                    ScriptProperty sp = se.Properties.ElementAt(d);
                                    switch (sp.Name)
                                    {
                                        case "ThisRecipe":
                                            sp.Flags = ScriptProperty.Flag.Edited;
                                            ((ScriptObjectProperty)sp).Object = new FormLink<ISkyrimMajorRecordGetter>(newRecipe.FormKey);
                                            thisRecipeExists = true;
                                            break;
                                        case "NoValueAfterRead":
                                            sp.Flags = ScriptProperty.Flag.Edited;
                                            ((ScriptBoolProperty)sp).Data = !(bool)Config?.HasValueAfterRead!;
                                            noValueAfterReadExists = true;
                                            break;
                                        case "CACO_AlchemyRecipesRead":
                                            alchemyRecipesReadExists = true;
                                            break;
                                    }
                                    for (int m = 0; m < 3; m++)
                                        if (sp.Name.Equals("Ingredient0" + (m + 1)))
                                            if (ic.MyIngredients.Length > m)
                                            {
                                                sp.Flags = ScriptProperty.Flag.Edited;
                                                ((ScriptObjectProperty)sp).Object = new FormLink<ISkyrimMajorRecordGetter>(ic.MyIngredients[m].FormKey);
                                                ingredientExist[m] = true;
                                            }
                                            else
                                                se.Properties.Remove(sp);
                                    for (int m = 0; m < 3; m++)
                                        for (int n = 0; n < 4; n++)
                                            if (sp.Name.Equals("Ingredient0" + (m + 1) + "Effect" + (n + 1)))
                                                if (ingredientEffectIndex[m, n] != -1)
                                                {
                                                    sp.Flags = ScriptProperty.Flag.Edited;
                                                    ((ScriptIntProperty)sp).Data = ingredientEffectIndex[m, n];
                                                    ingredientEffectExist[m, n] = true;
                                                }
                                                else
                                                    se.Properties.Remove(sp);
                                }
                                for (int m = 0; m < ingredientExist.Length; m++)
                                    if (ic.MyIngredients.Length > m)
                                        if (!ingredientExist[m])
                                        {
                                            ScriptObjectProperty sop = new ScriptObjectProperty();
                                            sop.Object = new FormLink<ISkyrimMajorRecordGetter>(ic.MyIngredients[m].FormKey);
                                            sop.Name = "Ingredient0" + (m + 1);
                                            sop.Flags = ScriptProperty.Flag.Edited;
                                            se.Properties.Add(sop);
                                        }
                                for (int m = 0; m < 3; m++)
                                    for (int n = 0; n < 4; n++)
                                        if (ic.MyIngredients.Length > m)
                                            if (!ingredientEffectExist[m, n] && ingredientEffectIndex[m, n] != -1)
                                            {
                                                ScriptIntProperty sip = new ScriptIntProperty();
                                                sip.Data = ingredientEffectIndex[m, n];
                                                sip.Name = "Ingredient0" + (m + 1) + "Effect" + (n + 1);
                                                sip.Flags = ScriptProperty.Flag.Edited;
                                                se.Properties.Add(sip);
                                            }
                                if (!thisRecipeExists)
                                {
                                    ScriptObjectProperty sop = new ScriptObjectProperty();
                                    sop.Object = new FormLink<ISkyrimMajorRecordGetter>(newRecipe.FormKey);
                                    sop.Name = "ThisRecipe";
                                    sop.Flags = ScriptProperty.Flag.Edited;
                                    se.Properties.Add(sop);
                                }
                                if (!noValueAfterReadExists)
                                {
                                    ScriptBoolProperty sbp = new ScriptBoolProperty();
                                    sbp.Data = (bool)Config?.HasValueAfterRead!;
                                    sbp.Name = "NoValueAfterRead";
                                    sbp.Flags = ScriptProperty.Flag.Edited;
                                    se.Properties.Add(sbp);
                                }
                                if (!alchemyRecipesReadExists)
                                {
                                    FormLink<ISkyrimMajorRecordGetter> fl = new FormLink<ISkyrimMajorRecordGetter>(new FormKey(ModKey.FromNameAndExtension("Complete Alchemy & Cooking Overhaul.esp"), 0xA2C667));
                                    ScriptObjectProperty sop = new ScriptObjectProperty();
                                    sop.Object = fl;
                                    sop.Name = "CACO_AlchemyRecipesRead";
                                    sop.Flags = ScriptProperty.Flag.Edited;
                                    se.Properties.Add(sop);
                                }
                            }
                        }
                    }
                }

                mods[modIndex].Books.Set((Book)newRecipe);
                LeveledItemEntry lie = new LeveledItemEntry();
                LeveledItemEntryData data = new LeveledItemEntryData();
                data.Level = 1;
                data.Count = 1;
                data.Reference = new FormLink<IItemGetter>(newRecipe.FormKey);
                lie.Data = data;
                switch (ic.Type)
                {

                    case 0:
                        potionRecipeLVLIentriesdata.ElementAt(modIndex)[potionIndex[modIndex] / LeveledListSize].Reference = new FormLink<ILeveledItem>(potionRecipeLVLIs.ElementAt(modIndex)[potionIndex[modIndex] / LeveledListSize].FormKey);
                        potionRecipeLVLIentries.ElementAt(modIndex)[potionIndex[modIndex] / LeveledListSize].Data = potionRecipeLVLIentriesdata.ElementAt(modIndex)[potionIndex[modIndex] / LeveledListSize];
                        potionRecipeLVLIs.ElementAt(modIndex)[potionIndex[modIndex] / LeveledListSize].Entries?.Add(lie);
                        potionIndex[modIndex]++;
                        break;
                    case 1:
                        poisonRecipeLVLIentriesdata.ElementAt(modIndex)[poisonIndex[modIndex] / LeveledListSize].Reference = new FormLink<ILeveledItem>(poisonRecipeLVLIs.ElementAt(modIndex)[poisonIndex[modIndex] / LeveledListSize].FormKey);
                        poisonRecipeLVLIentries.ElementAt(modIndex)[poisonIndex[modIndex] / LeveledListSize].Data = poisonRecipeLVLIentriesdata.ElementAt(modIndex)[poisonIndex[modIndex] / LeveledListSize];
                        poisonRecipeLVLIs.ElementAt(modIndex)[poisonIndex[modIndex] / LeveledListSize].Entries?.Add(lie);
                        poisonIndex[modIndex]++;
                        break;
                    case 2:
                        impurepotionRecipeLVLIentriesdata.ElementAt(modIndex)[impurepotionIndex[modIndex] / LeveledListSize].Reference = new FormLink<ILeveledItem>(impurepotionRecipeLVLIs.ElementAt(modIndex)[impurepotionIndex[modIndex] / LeveledListSize].FormKey);
                        impurepotionRecipeLVLIentries.ElementAt(modIndex)[impurepotionIndex[modIndex] / LeveledListSize].Data = impurepotionRecipeLVLIentriesdata.ElementAt(modIndex)[impurepotionIndex[modIndex] / LeveledListSize];
                        impurepotionRecipeLVLIs.ElementAt(modIndex)[impurepotionIndex[modIndex] / LeveledListSize].Entries?.Add(lie);
                        impurepotionIndex[modIndex]++;
                        break;
                }
                i++;
            }

            Console.WriteLine("Linking recipes to potion leveled list");
            IEnumerable<ILeveledItemGetter> lvlilists = from list in state.LoadOrder.PriorityOrder.OnlyEnabled().LeveledItem().WinningOverrides() where list.EditorID?.Equals("LItemPotionAll") == true select list;
            ILeveledItemGetter allList = lvlilists.ToList()[0];
            LeveledItem modifiedList = mods[0].LeveledItems.GetOrAddAsOverride(allList);

            int addCount = 0;

            for (int j = 0; j < mods.Length; j++)
            {
                uint potionIndex1 = 0;
                uint poisonIndex1 = 0;
                uint impurepotionIndex1 = 0;
                for (int l = 0; l < masterpotionRecipeListCount[j]; l++)
                {
                    masterpotionRecipeLVLIentriesdata.ElementAt(j)[l].Reference = new FormLink<ILeveledItem>(masterpotionRecipeLVLIs.ElementAt(j)[l].FormKey);
                    masterpotionRecipeLVLIentries.ElementAt(j)[l].Data = masterpotionRecipeLVLIentriesdata.ElementAt(j)[l];
                    for (int k = 0; k < LeveledListSize; k++)
                    {
                        if (potionIndex1 < potionRecipeLVLIentries.ElementAt(j).Length)
                            masterpotionRecipeLVLIs.ElementAt(j)[l].Entries?.Add(potionRecipeLVLIentries.ElementAt(j)[potionIndex1++]);
                        else if (poisonIndex1 < poisonRecipeLVLIentries.ElementAt(j).Length)
                            masterpotionRecipeLVLIs.ElementAt(j)[l].Entries?.Add(poisonRecipeLVLIentries.ElementAt(j)[poisonIndex1++]);
                        else if (impurepotionIndex1 < impurepotionRecipeLVLIentries.ElementAt(j).Length)
                            masterpotionRecipeLVLIs.ElementAt(j)[l].Entries?.Add(impurepotionRecipeLVLIentries.ElementAt(j)[impurepotionIndex1++]);
                        else
                            break;
                    }
                    mainpotionRecipeLVLI[j].Entries?.Add(masterpotionRecipeLVLIentries.ElementAt(j)[l]);
                }
                for (int l = 0; l < potionRecipeLVLIs.ElementAt(j).Length; l++)
                {
                    LeveledItem li = potionRecipeLVLIs.ElementAt(j)[l];
                    splitIndexCount = addCount / splitIndex;
                    if (addCount > (splitIndex + splitIndexCount))
                        splitIndexCount += splitIndex;
                    int modIndex = splitIndexCount / splitIndex;
                    if (modIndex > Config?.ESPCount - 1)
                        modIndex = ((int)Config?.ESPCount!) - 1;
                    mods[modIndex].LeveledItems.Set(li);
                    addCount++;
                }
                for (int l = 0; l < poisonRecipeLVLIs.ElementAt(j).Length; l++)
                {
                    LeveledItem li = poisonRecipeLVLIs.ElementAt(j)[l];
                    splitIndexCount = addCount / splitIndex;
                    if (addCount > (splitIndex + splitIndexCount))
                        splitIndexCount += splitIndex;
                    int modIndex = splitIndexCount / splitIndex;
                    if (modIndex > Config?.ESPCount - 1)
                        modIndex = ((int)Config?.ESPCount!) - 1;
                    mods[modIndex].LeveledItems.Set(li);
                    addCount++;
                }
                for (int l = 0; l < impurepotionRecipeLVLIs.ElementAt(j).Length; l++)
                {
                    LeveledItem li = impurepotionRecipeLVLIs.ElementAt(j)[l];
                    splitIndexCount = addCount / splitIndex;
                    if (addCount > (splitIndex + splitIndexCount))
                        splitIndexCount += splitIndex;
                    int modIndex = splitIndexCount / splitIndex;
                    if (modIndex > Config?.ESPCount - 1)
                        modIndex = ((int)Config?.ESPCount!) - 1;
                    mods[modIndex].LeveledItems.Set(li);
                    addCount++;
                }
                for (int l = 0; l < masterpotionRecipeLVLIs.ElementAt(j).Length; l++)
                {
                    LeveledItem li = masterpotionRecipeLVLIs.ElementAt(j)[l];
                    splitIndexCount = addCount / splitIndex;
                    if (addCount > (splitIndex + splitIndexCount))
                        splitIndexCount += splitIndex;
                    int modIndex = splitIndexCount / splitIndex;
                    if (modIndex > Config?.ESPCount - 1)
                        modIndex = ((int)Config?.ESPCount!) - 1;
                    mods[modIndex].LeveledItems.Set(li);
                    addCount++;
                }

                for (int k = 0; k < mainpotionRecipeLVLI.Length; k++)
                {
                    mainpotionRecipeLVLIentrydata[k].Reference = new FormLink<ILeveledItem>(mainpotionRecipeLVLI[k].FormKey);
                    mainpotionRecipeLVLIentry[k].Data = mainpotionRecipeLVLIentrydata[k];
                    mainpotionRecipeLVLIentrydata[k].Count = 1;
                    mainpotionRecipeLVLIentrydata[k].Level = 1;
                    modifiedList.Entries?.Add(mainpotionRecipeLVLIentry[k]);
                    mods[k].LeveledItems.Set(mainpotionRecipeLVLI[k]);
                }

                Console.WriteLine("Adding recipes to defined containers");
                IEnumerable<IContainerGetter> chests = from list in state.LoadOrder.PriorityOrder.OnlyEnabled().Container().WinningOverrides() where ContainerEditorIDs?.ToList().Contains(list.EditorID!) == true select list;
                ContainerEntry potionListContainerEntry = new ContainerEntry();
                ContainerItem potionListContainerItem = new ContainerItem();
                potionListContainerItem.Item = new FormLink<ILeveledItem>(mainpotionRecipeLVLI[j].FormKey);
                potionListContainerItem.Count = 1;
                potionListContainerEntry.Item = potionListContainerItem;
                foreach (IContainerGetter chest in chests)
                {
                    Container rChest = mods[0].Containers.GetOrAddAsOverride(chest);
                    rChest.Items?.Add(potionListContainerEntry);
                }
            }
            Console.WriteLine("Writing " + RecipeMakeCount + " recipes to file.");
            for (int u = 0; u < mods.Length; u++)
            {
                Console.WriteLine("Writing ESP " + Config?.ESPPath! + modkeys[u].FileName);
                SkyrimMod mod = mods[u];
                mod.WriteToBinary(Config?.ESPPath! + modkeys[u].FileName);
            }
        }
    }
    public class IngredientCombination
    {
        string? recipeName;
        IIngredientGetter[] myIngredients;
        string[]? myEffects;
        FormKey[]? myEffectsKeys;
        string? potionString;
        int type = 0;
        public IngredientCombination(String? recipeName, IIngredientGetter[] ingredients, string[]? effects, FormKey[]? effectsKeys, string? potionString, int type)
        {
            this.recipeName = recipeName;
            this.myIngredients = ingredients;
            this.myEffects = effects;
            this.myEffectsKeys = effectsKeys;
            this.potionString = potionString;
            this.type = type;
        }
        public IIngredientGetter[] MyIngredients { get => myIngredients; set => myIngredients = value; }
        public string[]? MyEffects { get => myEffects; set => myEffects = value; }
        public string? PotionString { get => potionString; set => potionString = value; }
        public string? RecipeName { get => recipeName; set => recipeName = value; }
        public int Type { get => type; set => type = value; }
        public FormKey[]? MyEffectsKeys { get => myEffectsKeys; set => myEffectsKeys = value; }
    }
    /* Worker Thread Class */
    class ListProcessor
    {
        int threadid, startIndex;
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state;
        IEnumerable<IIngredientGetter> ingredients;
        public ListProcessor(int threadid, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IEnumerable<IIngredientGetter> ingredients, int startIndex)
        {
            this.threadid = threadid;
            this.state = state;
            this.ingredients = ingredients;
            this.startIndex = startIndex;
        }
        public void run()
        {
            int i = startIndex;
            foreach (IIngredientGetter ingredient in ingredients)//loop through all ingredients
            {
                if (string.IsNullOrEmpty(ingredient.EditorID))
                {
                    i++;
                    continue;
                }
                List<IIngredientGetter> remainingIngredients = Program.AllIngredients!.Skip(i).ToList();
                IIngredientGetter[] potionRecipeList = getIngredientsMatchingOneIngredient(ingredient, remainingIngredients);
                for (int m = 0; m < potionRecipeList.Length; m++)
                {
                    IIngredientGetter ingredient2 = potionRecipeList[m];
                    IEnumerable<FormKey> formkeys = getEffectFormKeys(ingredient);
                    IEnumerable<FormKey> formkeys2 = getEffectFormKeys(ingredient2);
                    formkeys = formkeys.Intersect(formkeys2).Distinct();
                    FormKey[] formkeysA = formkeys.ToArray();
                    if (formkeysA.Length < 1)
                        continue;
                    string potionString = "";//Define main text for recipe
                    if (Program.Config?.MinimalRecipeText == false)
                        potionString += "<font face='$HandwrittenFont'><font size='26'>";
                    potionString += "-<b>" + (ingredient.Name + "<br><b>-<b>" + ingredient2.Name + "</b>");

                    List<string?> mgeflist = new List<string?>();
                    List<string?> mgeflists = new List<string?>();
                    List<bool> mgeflistD = new List<bool>();
                    List<FormKey> baseEffectFormKeys = new List<FormKey>();
                    for (int n = 0; n < formkeysA.Length; n++)
                    {
                        baseEffectFormKeys.Add(formkeysA[n]);
                        state.LinkCache.TryResolve<IMagicEffectGetter>(formkeysA[n], out var mgeffect);
                        mgeflist.Add(mgeffect?.Name?.String);
                        mgeflists.AddRange(mgeffect?.Name?.String?.Split()!);
                        IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? thisKeywords = mgeffect?.Keywords;
                        if (mgeffect?.Flags.HasFlag(MagicEffect.Flag.Detrimental) == true || mgeffect?.Flags.HasFlag(MagicEffect.Flag.Hostile) == true && (thisKeywords?.Intersect(Program.BadKeywordsF!).Any() == true))
                            mgeflistD.Add(true);
                        else
                            mgeflistD.Add(false);
                    }
                    string prefix = "Potion";
                    int type = 0;
                    if (mgeflistD.All(x => x.Equals(true)))
                    {
                        prefix = "Poison";
                        type = 1;
                        if (mgeflist.Count <= Program.Config?.PoisonSkipThreshold)
                            continue;
                        Program.OurMutex2.WaitOne();
                        Program.PoisonRecipeCount++;
                        Program.OurMutex2.ReleaseMutex();

                    }
                    else if (mgeflistD.Contains(true))//Check if effects match poison and potion
                    {
                        prefix = "Impure Potion";
                        type = 2;
                        if (mgeflist.Count <= Program.Config?.ImpureSkipThreshold)
                            continue;
                        Program.OurMutex2.WaitOne();
                        Program.ImpurepotionRecipeCount++;
                        Program.OurMutex2.ReleaseMutex();
                    }
                    else
                    {
                        if (mgeflist.Count <= Program.Config?.PotionSkipThreshold)
                            continue;
                        Program.OurMutex2.WaitOne();
                        Program.PotionRecipeCount++;
                        Program.OurMutex2.ReleaseMutex();
                    }
                    if (Program.Config?.MinimalRecipeText == false)
                        potionString += "</font><font face='$HandwrittenFont'><font size='26'><br> to make " + prefix + " of: <br></font><font face='$HandwrittenFont'><font size='26'>";
                    else
                        potionString += "<br>";
                    string potionName = "Recipe: ";//Define recipe name
                    for (int k = 0; k < mgeflist.Count; k++)
                    {
                        if (k+1 > Program.Config?.MaxEffectNameCount && k > 0)
                            break;
                        if (k > 0)
                        {
                            potionName += " and ";
                            potionString += "<br>";
                        }
                        potionName += mgeflist[k];
                        potionString += mgeflist[k];
                    }
                    string sstring = "";

                    if (mgeflist.Count > 1)
                        sstring = "s";
                    if (Program.Config?.MinimalRecipeText == false)
                    {
                        potionString += "<br></font><font size='14'> Contains " + mgeflist.Count + " Effect" + sstring;
                        potionString += "<\\font>";
                    }
                    IIngredientGetter[] ingrss = { ingredient, ingredient2 };
                    Program.OurMutex.WaitOne();
                    IngredientCombination ingrcombo = new IngredientCombination(potionName, ingrss, mgeflist?.ToArray()!, baseEffectFormKeys.ToArray(), potionString, type);
                    Program.Combinations.Add(ingrcombo);
                    Program.OurMutex.ReleaseMutex();
                }
                int j = i + 1;
                foreach (IIngredientGetter ingredient2 in remainingIngredients)
                {
                    if (string.IsNullOrEmpty(ingredient2.EditorID))
                    {
                        j++;
                        continue;
                    }
                    List<IIngredientGetter> remainingIngredients2 = Program.AllIngredients!.Skip(j).ToList();
                    IIngredientGetter[] potionRecipeList2 = getIngredientsMatchingTwoIngredients(ingredient, ingredient2, remainingIngredients2);
                    for (int m = 0; m < potionRecipeList2.Length; m++)
                    {
                        IIngredientGetter ingredient3 = potionRecipeList2[m];
                        IEnumerable<FormKey> formkeys = getEffectFormKeys(ingredient);
                        IEnumerable<FormKey> formkeys2 = getEffectFormKeys(ingredient2);
                        IEnumerable<FormKey> formkeys3 = getEffectFormKeys(ingredient3);
                        List<FormKey> formkeys1m = formkeys.Intersect(formkeys2).ToList();
                        List<FormKey> formkeys2m = formkeys3.Intersect(formkeys).ToList();
                        List<FormKey> formkeys3m = formkeys3.Intersect(formkeys2).ToList();
                        formkeys1m.AddRange(formkeys2m);
                        formkeys1m.AddRange(formkeys3m);
                        formkeys = formkeys1m.AsEnumerable().Distinct();
                        FormKey[] formkeysA = formkeys.ToArray();
                        if (formkeysA.Length < 1)
                            continue;
                        string potionString = "";//Define main text for recipe
                        if (Program.Config?.MinimalRecipeText == false)
                            potionString += "<font face='$HandwrittenFont'><font size='26'>";
                        potionString = "-<b>" + (ingredient.Name + "<br></b>-<b>" + ingredient2.Name + "<br></b>-<b>" + ingredient3.Name + "</b>");
                        List<string?> mgeflist = new List<string?>();
                        List<string?> mgeflists = new List<string?>();
                        List<bool> mgeflistD = new List<bool>();
                        List<FormKey> baseEffectFormKeys = new List<FormKey>();
                        for (int n = 0; n < formkeysA.Length; n++)
                        {
                            baseEffectFormKeys.Add(formkeysA[n]);
                            state.LinkCache.TryResolve<IMagicEffectGetter>(formkeysA[n], out var mgeffect);
                            mgeflist.Add(mgeffect?.Name?.String);
                            mgeflists.AddRange(mgeffect?.Name?.String?.Split()!);
                            IReadOnlyList<IFormLinkGetter<IKeywordGetter>>? thisKeywords = mgeffect?.Keywords;
                            if (mgeffect?.Flags.HasFlag(MagicEffect.Flag.Detrimental) == true || mgeffect?.Flags.HasFlag(MagicEffect.Flag.Hostile) == true && (thisKeywords?.Intersect(Program.BadKeywordsF!).Any() == true))
                                mgeflistD.Add(true);
                            else
                                mgeflistD.Add(false);
                        }
                        string prefix = "Potion";
                        int type = 0;
                        if (mgeflistD.All(x => x.Equals(true)))
                        {
                            prefix = "Poison";
                            type = 1;
                            if (mgeflist.Count <= Program.Config?.PoisonSkipThreshold)
                                continue;
                            Program.OurMutex2.WaitOne();
                            Program.PoisonRecipeCount++;
                            Program.OurMutex2.ReleaseMutex();
                        }
                        else if (mgeflistD.Contains(true))//Check if effects match poison and potion
                        {
                            prefix = "Impure Potion";
                            type = 2;
                            if (mgeflist.Count <= Program.Config?.ImpureSkipThreshold)
                                continue;
                            Program.OurMutex2.WaitOne();
                            Program.ImpurepotionRecipeCount++;
                            Program.OurMutex2.ReleaseMutex();
                        }
                        else
                        {
                            if (mgeflist.Count <= Program.Config?.PotionSkipThreshold)
                                continue;
                            Program.OurMutex2.WaitOne();
                            Program.PotionRecipeCount++;
                            Program.OurMutex2.ReleaseMutex();
                        }
                        if (Program.Config?.MinimalRecipeText == false)
                            potionString += "</font><font face='$HandwrittenFont'><font size='26'><br> to make " + prefix + " of: <br></font><font face='$HandwrittenFont'><font size='26'>";
                        else
                            potionString += "<br>";
                        string potionName = "Recipe: ";
                        for (int k = 0; k < mgeflist.Count; k++)
                        {
                            if (k > 0)
                            {
                                potionName += " and ";
                                potionString += "<br>";
                            }
                            potionName += mgeflist[k];
                            potionString += mgeflist[k];
                        }
                        string sstring = "";

                        if (mgeflist.Count > 1)
                            sstring = "s";
                        if (Program.Config?.MinimalRecipeText == false)
                        {
                            potionString += "<br></font><font size='14'> Contains " + mgeflist.Count + " Effect" + sstring;
                            potionString += "<\\font>";
                        }
                        IIngredientGetter[] ingrss = { ingredient, ingredient2, ingredient3 };
                        Program.OurMutex.WaitOne();
                        IngredientCombination ingrcombo = new IngredientCombination(potionName, ingrss, mgeflist?.ToArray()!, baseEffectFormKeys.ToArray(), potionString, type);
                        Program.Combinations.Add(ingrcombo);
                        Program.OurMutex.ReleaseMutex();
                    }
                    j++;
                }
                i++;
                Program.OurMutex.WaitOne();
                Program.TotalProcessedCount++;
                if (Program.TotalIngredientCount <= Program.TotalProcessedCount)
                    Program.FinishedProcessing = true;
                Program.OurMutex.ReleaseMutex();
            }
        }
        private IIngredientGetter[] getIngredientsMatchingOneIngredient(IIngredientGetter firstIngredient, IEnumerable<IIngredientGetter> otherIngredients)
        {
            List<IIngredientGetter> matchingIngredients = new List<IIngredientGetter>();
            List<FormKey> firstIngredientEffectKeys = getEffectFormKeys(firstIngredient);

            foreach (IIngredientGetter ieg in otherIngredients)
            {
                List<FormKey> otherIngredientEffectKeys = getEffectFormKeys(ieg);
                if (otherIngredientEffectKeys.Intersect(firstIngredientEffectKeys).Any())
                    matchingIngredients.Add(ieg);
            }
            return matchingIngredients.ToArray();
        }

        private IIngredientGetter[] getIngredientsMatchingTwoIngredients(IIngredientGetter firstIngredient, IIngredientGetter secondIngredient, IEnumerable<IIngredientGetter> otherIngredients)
        {
            otherIngredients = from otherIngredient in otherIngredients where !secondIngredient.FormKey.Equals(firstIngredient.FormKey) && !otherIngredient.FormKey.Equals(secondIngredient.FormKey) && !otherIngredient.FormKey.Equals(firstIngredient.FormKey) select otherIngredient;
            List<IIngredientGetter> matchingIngredients = new List<IIngredientGetter>();
            List<FormKey> firstIngredientEffectKeys = getEffectFormKeys(firstIngredient);
            List<FormKey> secondIngredientEffectKeys = getEffectFormKeys(secondIngredient);
            foreach (IIngredientGetter ieg in otherIngredients)
            {
                List<FormKey> otherIngredientEffectKeys = getEffectFormKeys(ieg);
                if ((firstIngredientEffectKeys.Intersect(secondIngredientEffectKeys).Any() || firstIngredientEffectKeys.Intersect(otherIngredientEffectKeys).Any()) && (secondIngredientEffectKeys.Intersect(firstIngredientEffectKeys).Any() || secondIngredientEffectKeys.Intersect(otherIngredientEffectKeys).Any()) && (otherIngredientEffectKeys.Intersect(firstIngredientEffectKeys).Any() || otherIngredientEffectKeys.Intersect(secondIngredientEffectKeys).Any()))
                    matchingIngredients.Add(ieg);
            }
            return matchingIngredients.ToArray();
        }

        private List<FormKey> getEffectFormKeys(IIngredientGetter ingredient)
        {
            List<FormKey> formkeys = new List<FormKey>();
            foreach (IEffectGetter effect in ingredient.Effects)
                formkeys.Add(effect.BaseEffect.FormKey);
            return formkeys;
        }
    }
}
static class Extensions
{
    public static IEnumerable<IEnumerable<IIngredientGetter>> Partition<IIngredientGetter>(this IEnumerable<IIngredientGetter> items, int partitionSize)
    {
        return new PartitionHelper<IIngredientGetter>(items, partitionSize);
    }
    public static void Shuffle<T>(this IList<T> list)//Uwe Keim stackoverflow
    {
        int n = list.Count;
        while (n > 1)
        {
            n--;
            int k = ThreadSafeRandom.ThisThreadsRandom.Next(n + 1);
            T value = list[k];
            list[k] = list[n];
            list[n] = value;
        }
    }
    private sealed class PartitionHelper<IIngredientGetter> : IEnumerable<IEnumerable<IIngredientGetter>>
    {
        readonly IEnumerable<IIngredientGetter> items;
        readonly int partitionSize;
        bool hasMoreItems;

        internal PartitionHelper(IEnumerable<IIngredientGetter> i, int ps)
        {
            items = i;
            partitionSize = ps;
        }

        public IEnumerator<IEnumerable<IIngredientGetter>> GetEnumerator()
        {
            using (var enumerator = items.GetEnumerator())
            {
                hasMoreItems = enumerator.MoveNext();
                while (hasMoreItems)
                    yield return GetNextBatch(enumerator).ToList();
            }
        }

        IEnumerable<IIngredientGetter> GetNextBatch(IEnumerator<IIngredientGetter> enumerator)
        {
            for (int i = 0; i < partitionSize; ++i)
            {
                yield return enumerator.Current;
                hasMoreItems = enumerator.MoveNext();
                if (!hasMoreItems)
                    yield break;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    public static class ThreadSafeRandom
    {
        [ThreadStatic] private static Random? Local;

        public static Random ThisThreadsRandom
        {
            get { return Local ?? (Local = new Random(unchecked(Environment.TickCount * 31 + Thread.CurrentThread.ManagedThreadId))); }
        }
    }
}