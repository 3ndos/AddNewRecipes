using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace AddNewRecipes
{
    public class Program
    {
        static Lazy<Settings> LazySettings = new Lazy<Settings>();
        public static Settings Settings => LazySettings.Value;
        public static HashSet<string>? ContainerEditorIDs { get; set; } = null!;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch).SetAutogeneratedSettings(
                    "Settings",
                    "settings.json",
                    out LazySettings)
                .Run(args, new RunPreferences()
                {
                    ActionsForEmptyArgs = new RunDefaultPatcher()
                    {
                        IdentifyingModKey = "AddNewRecipes.esp",
                        TargetRelease = GameRelease.SkyrimSE,
                    }
                });
        }
        private static string[] BadKeywords = { "MagicAlchHarmful" };
        public static List<IngredientCombination> Combinations = new List<IngredientCombination>();
        public static Mutex OurMutex2 = new Mutex(), OurMutex = new Mutex();
        private static int Percent;
        public static bool FinishedProcessing;
        public static uint PotionRecipeCount, PoisonRecipeCount, ImpurepotionRecipeCount;
        public static int ReportedCount = -1, TotalProcessedCount = 0, TotalIngredientCount = 0;
        public static IEnumerable<IIngredientGetter>? AllIngredients;
        public static Stopwatch StopWatch = new Stopwatch();
        public static IEnumerable<IFormLink<IKeyword>>? BadKeywordsF;
        public static Settings? Config = new Settings();
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            try
            {
                //Reading the Settings from the settings.json file
                var content = File.ReadAllText(state.RetrieveConfigFile("settings.json"));
                Config = JsonConvert.DeserializeObject<Settings>(content, new JsonSerializerSettings
                {
                    NullValueHandling = NullValueHandling.Ignore
                })!;
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine("Cannot find settings file, using default values.");
            }


            ContainerEditorIDs = new HashSet<string>(Config?.ContainerEditorIds!);
            BadKeywordsF = (from keyword in state.LoadOrder.PriorityOrder.OnlyEnabled().Keyword().WinningOverrides() where BadKeywords.Contains(keyword.EditorID) select (IFormLink<IKeyword>)(new FormLink<IKeyword>(keyword.FormKey))).ToList();
            IEnumerable<IIngredientGetter> ingredients = state.LoadOrder.PriorityOrder.OnlyEnabled().Ingredient().WinningOverrides().Where(x => !Config.SkipPlugins.Contains(x.FormKey.ModKey.Name.ToLower())).Where(x => (!Config.SkipIngredients.Intersect(x.Name?.ToString()?.Split()!).Any() || Config.SkipIngredients.Contains(x.Name?.ToString()!))).Where(x => !String.IsNullOrEmpty(x.EditorID)).ToList();
            AllIngredients = ingredients;
            Percent = (int)(ingredients.Count() * Config?.OutputPercentage!);
            TotalIngredientCount = ingredients.Count();
            Thread[] threads = new Thread[(int)Config?.WorkerThreadCount!];
            int partitionsize = (ingredients.Count() / (int)Config?.WorkerThreadCount!);
            /* Split ingredient list evenly across threads */
            IEnumerable<IIngredientGetter>[] ingredientsL = ingredients.Partition(partitionsize).ToArray();
            /* If there is a remainder add it to last thread */
            if (ingredientsL.Length > Config.WorkerThreadCount)
            {
                ingredientsL[ingredientsL.Length - 2] = ingredientsL[ingredientsL.Length - 2].Concat(ingredientsL[ingredientsL.Length - 1]);
            }
            StopWatch.Start();
            Console.WriteLine("Using " + Config?.WorkerThreadCount + " threads to handle " + partitionsize + " ingredients each.");
            int startIndex = 0;
            for (int u = 0; u < Config?.WorkerThreadCount; u++)
            {
                ListProcessor lp = new ListProcessor(u, state, ingredientsL[u], startIndex);
                threads[u] = new Thread(new ThreadStart(lp.run));
                threads[u].Start();
                startIndex += partitionsize;
            }
            while (!FinishedProcessing)
            {
                if (TotalProcessedCount % Percent == 0)
                {
                    if (ReportedCount != TotalProcessedCount)
                    {
                        Console.WriteLine(TotalProcessedCount + " out of " + ingredients.Count() + " ingredients processed.");
                        StopWatch.Stop();
                        Console.WriteLine("time elapsed:  " + StopWatch.Elapsed.TotalSeconds + " seconds");
                        StopWatch.Reset();
                        StopWatch.Start();
                        ReportedCount = TotalProcessedCount;
                    }
                }
                Thread.Sleep(100);
            };
            Console.WriteLine("Terminating Threads.");
            for (int u = 0; u < Config?.WorkerThreadCount; u++)
            {
                threads[u].Join();
            }
            Console.WriteLine("Creating Leveled lists...");
            IEnumerable<IBookGetter> books = from book in state.LoadOrder.PriorityOrder.Book().WinningOverrides() where book.FormKey.Equals(new FormKey(new ModKey("Skyrim", ModType.Master), 0x0F5CB1)) select book;
            IBookGetter noteTemplate = books.ToList()[0];
            Console.WriteLine("Creating " + Combinations.Count + " recipes.");
            Percent = (int)(Combinations.Count * Config?.OutputPercentage!);
            int i = 0;
            /* Main leveled list that gets added to recipe drop */
            LeveledItem mainpotionRecipeLVLI = state.PatchMod.LeveledItems.AddNew();
            LeveledItemEntry mainpotionRecipeLVLIentry = new LeveledItemEntry();
            mainpotionRecipeLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
            LeveledItemEntryData mainpotionRecipeLVLIentrydata = new LeveledItemEntryData();
            GlobalInt mainpotionGlobal = new GlobalInt(state.PatchMod.GetNextFormKey(), SkyrimRelease.SkyrimSE);
            mainpotionGlobal.Data = new Random().Next((int)Config?.MinChance!, (int)Config?.MaxChance!);
            state.PatchMod.Globals.Set(mainpotionGlobal);
            mainpotionRecipeLVLI.Global = mainpotionGlobal;
            mainpotionRecipeLVLI.EditorID = "mainpotionRecipeList";
            /* Must split sub leveled lists because it can only hold 128 items */
            uint potionRecipeListCount = (PotionRecipeCount / 128) + 1;
            uint poisonRecipeListCount = (PoisonRecipeCount / 128) + 1;
            uint impurepotionRecipeListCount = (ImpurepotionRecipeCount / 128) + 1;
            LeveledItem[] potionRecipeLVLIs = new LeveledItem[potionRecipeListCount];
            uint masterpotionRecipeListCount = ((potionRecipeListCount + poisonRecipeListCount + impurepotionRecipeListCount) / 128) + 1;
            LeveledItem[] masterpotionRecipeLVLIs = new LeveledItem[masterpotionRecipeListCount];
            LeveledItemEntry[] masterpotionRecipeLVLIentries = new LeveledItemEntry[masterpotionRecipeListCount];
            LeveledItemEntryData[] masterpotionRecipeLVLIentriesdata = new LeveledItemEntryData[masterpotionRecipeListCount];
            GlobalInt[] masterpotionGlobals = new GlobalInt[masterpotionRecipeListCount];
            LeveledItemEntry[] potionRecipeLVLIentries = new LeveledItemEntry[potionRecipeListCount];
            LeveledItemEntryData[] potionRecipeLVLIentriesdata = new LeveledItemEntryData[potionRecipeListCount];
            GlobalInt[] potionGlobals = new GlobalInt[potionRecipeListCount];
            for (int k = 0; k < masterpotionRecipeListCount; k++)
            {
                masterpotionRecipeLVLIentries[k] = new LeveledItemEntry();
                masterpotionRecipeLVLIentriesdata[k] = new LeveledItemEntryData();
                masterpotionRecipeLVLIs[k] = state.PatchMod.LeveledItems.AddNew();
                masterpotionRecipeLVLIs[k].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                masterpotionGlobals[k] = new GlobalInt(state.PatchMod.GetNextFormKey(), SkyrimRelease.SkyrimSE);
                masterpotionGlobals[k].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                state.PatchMod.Globals.Set(masterpotionGlobals[k]);
                masterpotionRecipeLVLIs[k].Global = masterpotionGlobals[k];
                masterpotionRecipeLVLIs[k].EditorID = "masterpotionRecipeList" + k;
                masterpotionRecipeLVLIentriesdata[k].Reference = masterpotionRecipeLVLIs[k].FormKey;
                masterpotionRecipeLVLIentriesdata[k].Level = 1;
                masterpotionRecipeLVLIentriesdata[k].Count = 1;
            }
            for (int l = 0; l < potionRecipeListCount; l++)
            {
                potionRecipeLVLIentries[l] = new LeveledItemEntry();
                potionRecipeLVLIentriesdata[l] = new LeveledItemEntryData();
                potionRecipeLVLIs[l] = state.PatchMod.LeveledItems.AddNew();
                potionRecipeLVLIs[l].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                potionGlobals[l] = new GlobalInt(state.PatchMod.GetNextFormKey(), SkyrimRelease.SkyrimSE);
                potionGlobals[l].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                state.PatchMod.Globals.Set(potionGlobals[l]);
                potionRecipeLVLIs[i].Global = potionGlobals[l];
                potionRecipeLVLIs[l].EditorID = "potionRecipeList" + l;
                potionRecipeLVLIentriesdata[l].Reference = potionRecipeLVLIs[l].FormKey;
                potionRecipeLVLIentriesdata[l].Level = 1;
                potionRecipeLVLIentriesdata[l].Count = 1;
            }
            LeveledItem[] poisonRecipeLVLIs = new LeveledItem[poisonRecipeListCount];
            LeveledItemEntry[] poisonRecipeLVLIentries = new LeveledItemEntry[poisonRecipeListCount];
            LeveledItemEntryData[] poisonRecipeLVLIentriesdata = new LeveledItemEntryData[poisonRecipeListCount];
            GlobalInt[] poisonGlobals = new GlobalInt[poisonRecipeListCount];
            for (int l = 0; l < poisonRecipeListCount; l++)
            {
                poisonRecipeLVLIentries[l] = new LeveledItemEntry();
                poisonRecipeLVLIentriesdata[l] = new LeveledItemEntryData();
                poisonRecipeLVLIs[l] = state.PatchMod.LeveledItems.AddNew();
                poisonRecipeLVLIs[l].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                poisonGlobals[l] = new GlobalInt(state.PatchMod.GetNextFormKey(), SkyrimRelease.SkyrimSE);
                poisonGlobals[l].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                state.PatchMod.Globals.Set(poisonGlobals[l]);
                poisonRecipeLVLIs[i].Global = poisonGlobals[l];
                poisonRecipeLVLIs[l].EditorID = "poisonRecipeList" + l;
                poisonRecipeLVLIentriesdata[l].Reference = poisonRecipeLVLIs[l].FormKey;
                poisonRecipeLVLIentriesdata[l].Level = 1;
                poisonRecipeLVLIentriesdata[l].Count = 1;
            }
            LeveledItem[] impurepotionRecipeLVLIs = new LeveledItem[impurepotionRecipeListCount];
            LeveledItemEntry[] impurepotionRecipeLVLIentries = new LeveledItemEntry[impurepotionRecipeListCount];
            LeveledItemEntryData[] impurepotionRecipeLVLIentriesdata = new LeveledItemEntryData[impurepotionRecipeListCount];
            GlobalInt[] impurepotionGlobals = new GlobalInt[impurepotionRecipeListCount];
            for (int l = 0; l < impurepotionRecipeListCount; l++)
            {
                impurepotionRecipeLVLIentries[l] = new LeveledItemEntry();
                impurepotionRecipeLVLIentriesdata[l] = new LeveledItemEntryData();
                impurepotionRecipeLVLIs[l] = state.PatchMod.LeveledItems.AddNew();
                impurepotionRecipeLVLIs[l].Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                impurepotionGlobals[l] = new GlobalInt(state.PatchMod.GetNextFormKey(), SkyrimRelease.SkyrimSE);
                impurepotionGlobals[l].Data = new Random().Next(5, 25);//Chance of picking a recipe from this list
                state.PatchMod.Globals.Set(impurepotionGlobals[l]);
                impurepotionRecipeLVLIs[i].Global = impurepotionGlobals[l];
                impurepotionRecipeLVLIs[l].EditorID = "impurepotionRecipeList" + l;
                impurepotionRecipeLVLIentriesdata[l].Reference = impurepotionRecipeLVLIs[l].FormKey;
                impurepotionRecipeLVLIentriesdata[l].Level = 1;
                impurepotionRecipeLVLIentriesdata[l].Count = 1;
            }
            Console.WriteLine("Splitting potions into lists (" + potionRecipeListCount + " " + poisonRecipeListCount + " " + impurepotionRecipeListCount + ")");
            uint potionIndex = 0, poisonIndex = 0, impurepotionIndex = 0;
            Dictionary<string, int> nameCache = new Dictionary<string, int>();
            foreach (IngredientCombination ic in Combinations)
            {
                if (i % Percent == 0)
                    Console.WriteLine(i + " out of " + Combinations.Count + " recipes created.");
                IBook newRecipe = noteTemplate.DeepCopy();
                newRecipe.FormKey = state.PatchMod.GetNextFormKey();
                string prefix = "[Potion]";
                if (ic.Type == 1)
                    prefix = "[Poison]";
                if (ic.Type == 2)
                    prefix = "[Impure Potion]";
                newRecipe.Description = prefix + ic.RecipeName;
                newRecipe.Name = ic.RecipeName;
                newRecipe.BookText = ic.PotionString;
                newRecipe.Weight = (float)Config?.RecipeWeight!;
                newRecipe.Value = (uint)Config?.RecipeValue!;
                string? name = "recipeof";
                foreach (string? s in ic.MyEffects!)
                    name += s;
                name = name.Replace(" ", string.Empty);
                int nameIndex = 0;
                if (nameCache.TryGetValue(name, out nameIndex))
                {
                    nameCache[name] = nameIndex + 1;
                    name = name + nameCache[name];
                }
                else
                {
                    nameCache.Add(name, 0);
                    name = name + "0";
                }
                newRecipe.EditorID = name;
                /* Add ingredients to CACO learning recipe script */
                if (state.LoadOrder.ContainsKey(ModKey.FromNameAndExtension("Complete Alchemy & Cooking Overhaul.esp")))
                {
                    string[] s = (from scriptentry in newRecipe.VirtualMachineAdapter?.Scripts where scriptentry.Name.Equals("CACO_AlchemyRecipeScript") select scriptentry.Name).ToArray();
                    if (s.Length < 1 && (Config?.LearnEffectsFromRecipe == true))//For adding recipe to a brand new item (not a copy of a vanilla recipe)
                    {
                        ScriptEntry cacoscript = new ScriptEntry();
                        cacoscript.Name = "CACO_AlchemyRecipeScript";
                        newRecipe.VirtualMachineAdapter?.Scripts.Add(cacoscript);
                    }
                    if (newRecipe.VirtualMachineAdapter?.Scripts != null)//For modiying a copy of a vanilla recipe modified by CACO(default)
                    {

                        for (int e = 0; e < newRecipe.VirtualMachineAdapter?.Scripts!.Count; e++)
                        {
                            ScriptEntry? se = newRecipe.VirtualMachineAdapter?.Scripts!.ElementAt(e);
                            if (se == null)
                                continue;
                            if (se.Name.Equals("CACO_AlchemyRecipeScript"))
                            {
                                if (Config?.LearnEffectsFromRecipe == false)
                                {
                                    newRecipe.VirtualMachineAdapter?.Scripts?.Remove(se);
                                    continue;
                                }
                                int[,] ingredientEffectIndex = new int[3, 4];
                                for (int j = 0; j < ingredientEffectIndex.GetLength(0); j++)
                                    for (int k = 0; k < ingredientEffectIndex.GetLength(1); k++)
                                        ingredientEffectIndex[j, k] = -1;
                                for (int j = 0; j < ic.MyIngredients.Length; j++)
                                {
                                    int offset = 0;
                                    for (int k = 0; k < ic.MyIngredients[j].Effects.Count; k++)
                                    {
                                        foreach (FormKey mgefformkey in ic.MyEffectsKeys!)
                                        {
                                            if (ic.MyIngredients[j].Effects[k] == null)
                                                continue;
                                            if (ic.MyIngredients[j].Effects[k].BaseEffect.FormKey.Equals(mgefformkey))
                                            {
                                                ingredientEffectIndex[j, offset++] = k;
                                            }
                                        }
                                    }

                                }
                                bool[,] ingredientEffectExist = new bool[3, 4];
                                bool[] ingredientExist = new bool[3];
                                bool thisRecipeExists = false, noValueAfterReadExists = false, alchemyRecipesReadExists = false;
                                for (int d = 0; d < se.Properties.Count; d++)//Scan CACO learning script properties
                                {
                                    ScriptProperty sp = se.Properties.ElementAt(d);
                                    switch (sp.Name)
                                    {
                                        case "ThisRecipe":
                                            sp.Flags = ScriptProperty.Flag.Edited;
                                            ((ScriptObjectProperty)sp).Object = new FormLink<ISkyrimMajorRecordGetter>(newRecipe.FormKey);
                                            thisRecipeExists = true;
                                            break;
                                        case "NoValueAfterRead":
                                            sp.Flags = ScriptProperty.Flag.Edited;
                                            ((ScriptBoolProperty)sp).Data = (bool)Config?.HasValueAfterRead!;
                                            noValueAfterReadExists = true;
                                            break;
                                        case "CACO_AlchemyRecipesRead":
                                            alchemyRecipesReadExists = true;
                                            break;
                                    }
                                    for (int j = 0; j < 3; j++)
                                        if (sp.Name.Equals("Ingredient0" + (j + 1)))
                                            if (ic.MyIngredients.Length > j)
                                            {
                                                sp.Flags = ScriptProperty.Flag.Edited;
                                                ((ScriptObjectProperty)sp).Object = new FormLink<ISkyrimMajorRecordGetter>(ic.MyIngredients[j].FormKey);
                                                ingredientExist[j] = true;
                                            }
                                            else
                                                se.Properties.Remove(sp);
                                    for (int j = 0; j < 3; j++)
                                        for (int k = 0; k < 4; k++)
                                            if (sp.Name.Equals("Ingredient0" + (j + 1) + "Effect" + (k + 1)))
                                                if (ingredientEffectIndex[j, k] != -1)
                                                {
                                                    sp.Flags = ScriptProperty.Flag.Edited;
                                                    ((ScriptIntProperty)sp).Data = ingredientEffectIndex[j, k];
                                                    ingredientEffectExist[j, k] = true;
                                                }
                                                else
                                                    se.Properties.Remove(sp);
                                }
                                for (int j = 0; j < ingredientExist.Length; j++)
                                    if (ic.MyIngredients.Length > j)
                                        if (!ingredientExist[j])
                                        {
                                            ScriptObjectProperty sop = new ScriptObjectProperty();
                                            sop.Object = new FormLink<ISkyrimMajorRecordGetter>(ic.MyIngredients[j].FormKey);
                                            sop.Name = "Ingredient0" + (j + 1);
                                            sop.Flags = ScriptProperty.Flag.Edited;
                                            se.Properties.Add(sop);
                                        }
                                for (int j = 0; j < 3; j++)
                                    for (int k = 0; k < 4; k++)
                                        if (ic.MyIngredients.Length > j)
                                            if (!ingredientEffectExist[j, k] && ingredientEffectIndex[j, k] != -1)
                                            {
                                                ScriptIntProperty sip = new ScriptIntProperty();
                                                sip.Data = ingredientEffectIndex[j, k];
                                                sip.Name = "Ingredient0" + (j + 1) + "Effect" + (k + 1);
                                                sip.Flags = ScriptProperty.Flag.Edited;
                                                se.Properties.Add(sip);
                                            }
                                if (!thisRecipeExists)
                                {
                                    ScriptObjectProperty sop = new ScriptObjectProperty();
                                    sop.Object = new FormLink<ISkyrimMajorRecordGetter>(newRecipe.FormKey);
                                    sop.Name = "ThisRecipe";
                                    sop.Flags = ScriptProperty.Flag.Edited;
                                    se.Properties.Add(sop);
                                }
                                if (!noValueAfterReadExists)
                                {
                                    ScriptBoolProperty sbp = new ScriptBoolProperty();
                                    sbp.Data = (bool)Config?.HasValueAfterRead!;
                                    sbp.Name = "NoValueAfterRead";
                                    sbp.Flags = ScriptProperty.Flag.Edited;
                                    se.Properties.Add(sbp);
                                }
                                if (!alchemyRecipesReadExists)
                                {
                                    FormList fl = new FormList(new FormKey(ModKey.FromNameAndExtension("Complete Alchemy & Cooking Overhaul.esp"), 0xA2C667), SkyrimRelease.SkyrimSE);
                                    ScriptObjectProperty sop = new ScriptObjectProperty();
                                    sop.Object = fl;
                                    sop.Name = "CACO_AlchemyRecipesRead";
                                    sop.Flags = ScriptProperty.Flag.Edited;
                                    se.Properties.Add(sop);
                                }
                            }
                        }
                    }
                }

                state.PatchMod.Books.Set((Book)newRecipe);
                LeveledItemEntry lie = new LeveledItemEntry();
                LeveledItemEntryData data = new LeveledItemEntryData();
                data.Level = 1;
                data.Count = 1;
                data.Reference = new FormLink<IItemGetter>(newRecipe.FormKey);
                lie.Data = data;
                switch (ic.Type)
                {

                    case 0:
                        potionRecipeLVLIentriesdata[potionIndex / 128].Reference = potionRecipeLVLIs[potionIndex / 128].FormKey;
                        potionRecipeLVLIentries[potionIndex / 128].Data = potionRecipeLVLIentriesdata[potionIndex / 128];
                        potionRecipeLVLIs[potionIndex / 128].Entries?.Add(lie);
                        potionIndex++;
                        break;
                    case 1:
                        poisonRecipeLVLIentriesdata[poisonIndex / 128].Reference = poisonRecipeLVLIs[poisonIndex / 128].FormKey;
                        poisonRecipeLVLIentries[poisonIndex / 128].Data = poisonRecipeLVLIentriesdata[poisonIndex / 128];
                        poisonRecipeLVLIs[poisonIndex / 128].Entries?.Add(lie);
                        poisonIndex++;
                        break;
                    case 2:
                        impurepotionRecipeLVLIentriesdata[impurepotionIndex / 128].Reference = impurepotionRecipeLVLIs[impurepotionIndex / 128].FormKey;
                        impurepotionRecipeLVLIentries[impurepotionIndex / 128].Data = impurepotionRecipeLVLIentriesdata[impurepotionIndex / 128];
                        impurepotionRecipeLVLIs[impurepotionIndex / 128].Entries?.Add(lie);
                        impurepotionIndex++;
                        break;
                }
                i++;
            }

            Console.WriteLine("Linking recipes to potion leveled list");
            IEnumerable<ILeveledItemGetter> lvlilists = from list in state.LoadOrder.PriorityOrder.OnlyEnabled().LeveledItem().WinningOverrides() where list.EditorID?.Equals("LItemPotionAll") == true select list;
            ILeveledItemGetter allList = lvlilists.ToList()[0];
            LeveledItem modifiedList = state.PatchMod.LeveledItems.GetOrAddAsOverride(allList);
            potionIndex = 0;
            poisonIndex = 0;
            impurepotionIndex = 0;
            for (int l = 0; l < masterpotionRecipeListCount; l++)
            {
                masterpotionRecipeLVLIentriesdata[l].Reference = masterpotionRecipeLVLIs[l].FormKey;
                masterpotionRecipeLVLIentries[l].Data = masterpotionRecipeLVLIentriesdata[l];
                for (int k = 0; k < 128; k++)
                {
                    if (potionIndex < potionRecipeLVLIentries.Length)
                        masterpotionRecipeLVLIs[l].Entries?.Add(potionRecipeLVLIentries[potionIndex++]);
                    else if (poisonIndex < poisonRecipeLVLIentries.Length)
                        masterpotionRecipeLVLIs[l].Entries?.Add(poisonRecipeLVLIentries[poisonIndex++]);
                    else if (impurepotionIndex < impurepotionRecipeLVLIentries.Length)
                        masterpotionRecipeLVLIs[l].Entries?.Add(impurepotionRecipeLVLIentries[impurepotionIndex++]);
                    else
                        break;
                }
                mainpotionRecipeLVLI.Entries?.Add(masterpotionRecipeLVLIentries[l]);
            }
            foreach (LeveledItem li in potionRecipeLVLIs)
                state.PatchMod.LeveledItems.Set(li);
            foreach (LeveledItem li in poisonRecipeLVLIs)
                state.PatchMod.LeveledItems.Set(li);
            foreach (LeveledItem li in impurepotionRecipeLVLIs)
                state.PatchMod.LeveledItems.Set(li);
            foreach (LeveledItem li in masterpotionRecipeLVLIs)
                state.PatchMod.LeveledItems.Set(li);

            mainpotionRecipeLVLIentrydata.Reference = mainpotionRecipeLVLI.FormKey;
            mainpotionRecipeLVLIentry.Data = mainpotionRecipeLVLIentrydata;
            mainpotionRecipeLVLIentrydata.Count = 1;
            mainpotionRecipeLVLIentrydata.Level = 1;
            modifiedList.Entries?.Add(mainpotionRecipeLVLIentry);
            state.PatchMod.LeveledItems.Set(mainpotionRecipeLVLI);
            Console.WriteLine("Adding recipes to defined containers");
            IEnumerable<IContainerGetter> chests = from list in state.LoadOrder.PriorityOrder.OnlyEnabled().Container().WinningOverrides() where ContainerEditorIDs?.ToList().Contains(list.EditorID!) == true select list;
            ContainerEntry potionListContainerEntry = new ContainerEntry();
            ContainerItem potionListContainerItem = new ContainerItem();
            potionListContainerItem.Item = mainpotionRecipeLVLI.FormKey;
            potionListContainerItem.Count = 1;
            potionListContainerEntry.Item = potionListContainerItem;
            foreach (IContainerGetter chest in chests)
            {
                Container rChest = state.PatchMod.Containers.GetOrAddAsOverride(chest);
                rChest.Items?.Add(potionListContainerEntry);
            }
        }
    }
    public class IngredientCombination
    {
        string? recipeName;
        IIngredientGetter[] myIngredients;
        string[]? myEffects;
        FormKey[]? myEffectsKeys;
        string? potionString;
        int type = 0;
        public IngredientCombination(String? recipeName, IIngredientGetter[] ingredients, string[]? effects, FormKey[]? effectsKeys, string? potionString, int type)
        {
            this.recipeName = recipeName;
            this.myIngredients = ingredients;
            this.myEffects = effects;
            this.myEffectsKeys = effectsKeys;
            this.potionString = potionString;
            this.type = type;
        }
        public IIngredientGetter[] MyIngredients { get => myIngredients; set => myIngredients = value; }
        public string[]? MyEffects { get => myEffects; set => myEffects = value; }
        public string? PotionString { get => potionString; set => potionString = value; }
        public string? RecipeName { get => recipeName; set => recipeName = value; }
        public int Type { get => type; set => type = value; }
        public FormKey[]? MyEffectsKeys { get => myEffectsKeys; set => myEffectsKeys = value; }
    }
    /* Worker Thread Class */
    class ListProcessor
    {
        int threadid, startIndex;
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state;
        IEnumerable<IIngredientGetter> ingredients;
        public ListProcessor(int threadid, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, IEnumerable<IIngredientGetter> ingredients, int startIndex)
        {
            this.threadid = threadid;
            this.state = state;
            this.ingredients = ingredients;
            this.startIndex = startIndex;
        }
        public void run()
        {
            int i = startIndex;
            foreach (IIngredientGetter ingredient in ingredients)//loop through all ingredients
            {
                if (string.IsNullOrEmpty(ingredient.EditorID))
                {
                    i++;
                    continue;
                }
                List<IIngredientGetter> remainingIngredients = Program.AllIngredients!.Skip(i).ToList();
                IIngredientGetter[] potionRecipeList = getIngredientsMatchingOneIngredient(ingredient, remainingIngredients);
                for (int m = 0; m < potionRecipeList.Length; m++)
                {
                    IIngredientGetter ingredient2 = potionRecipeList[m];
                    IEnumerable<FormKey> formkeys = getEffectFormKeys(ingredient);
                    IEnumerable<FormKey> formkeys2 = getEffectFormKeys(ingredient2);
                    formkeys = formkeys.Intersect(formkeys2).Distinct();
                    FormKey[] formkeysA = formkeys.ToArray();
                    if (formkeysA.Length < 1)
                        continue;
                    string potionString = "<font face='$HandwrittenFont'><font size='26'>";//Define main text for recipe
                    potionString += "-<b>" + (ingredient.Name + "<br><b>-<b>" + ingredient2.Name + "</b>");

                    List<string?> mgeflist = new List<string?>();
                    List<string?> mgeflists = new List<string?>();
                    List<bool> mgeflistD = new List<bool>();
                    List<FormKey> baseEffectFormKeys = new List<FormKey>();
                    for (int n = 0; n < formkeysA.Length; n++)
                    {
                        baseEffectFormKeys.Add(formkeysA[n]);
                        state.LinkCache.TryResolve<IMagicEffectGetter>(formkeysA[n], out var mgeffect);
                        mgeflist.Add(mgeffect?.Name?.String);
                        mgeflists.AddRange(mgeffect?.Name?.String?.Split()!);
                        IReadOnlyList<IFormLink<IKeywordGetter>>? thisKeywords = mgeffect.Keywords;
                        if (mgeffect.Flags.HasFlag(MagicEffect.Flag.Detrimental) || mgeffect.Flags.HasFlag(MagicEffect.Flag.Hostile) && (thisKeywords?.Intersect(Program.BadKeywordsF!).Any() == true))
                            mgeflistD.Add(true);
                        else
                            mgeflistD.Add(false);
                    }
                    string prefix = "Potion";
                    int type = 0;
                    if (mgeflistD.All(x => x.Equals(true)))
                    {
                        prefix = "Poison";
                        type = 1;
                        if (mgeflist.Count <= Program.Config?.PoisonSkipThreshold)
                            continue;
                        Program.OurMutex.WaitOne();
                        Program.PoisonRecipeCount++;
                        Program.OurMutex.ReleaseMutex();
                    }
                    else if (mgeflistD.Contains(true))//Check if effects match poison and potion
                    {
                        prefix = "Impure Potion";
                        type = 2;
                        if (mgeflist.Count <= Program.Config?.ImpureSkipThreshold)
                            continue;
                        Program.OurMutex.WaitOne();
                        Program.ImpurepotionRecipeCount++;
                        Program.OurMutex.ReleaseMutex();
                    }
                    else
                    {
                        if (mgeflist.Count <= Program.Config?.PotionSkipThreshold)
                            continue;
                        Program.OurMutex.WaitOne();
                        Program.PotionRecipeCount++;
                        Program.OurMutex.ReleaseMutex();
                    }
                    potionString += "</font><font face='$HandwrittenFont'><font size='26'><br> to make " + prefix + " of: <br></font><font face='$HandwrittenFont'><font size='26'>";
                    string potionName = "Recipe: ";//Define recipe name
                    for (int k = 0; k < mgeflist.Count; k++)
                    {
                        if (k > 0)
                        {
                            potionName += " and ";
                            potionString += "<br>";
                        }
                        potionName += mgeflist[k];
                        potionString += mgeflist[k];
                    }
                    string sstring = "";

                    if (mgeflist.Count > 1)
                        sstring = "s";

                    potionString += "<br></font><font size='14'> Contains " + mgeflist.Count + " Effect" + sstring;
                    potionString += "<\\font>";
                    IIngredientGetter[] ingrss = { ingredient, ingredient2 };
                    Program.OurMutex.WaitOne();
                    IngredientCombination ingrcombo = new IngredientCombination(potionName, ingrss, mgeflist?.ToArray()!, baseEffectFormKeys.ToArray(), potionString, type);
                    Program.Combinations.Add(ingrcombo);
                    Program.OurMutex.ReleaseMutex();
                }
                int j = i + 1;
                foreach (IIngredientGetter ingredient2 in remainingIngredients)
                {
                    if (string.IsNullOrEmpty(ingredient2.EditorID))
                    {
                        j++;
                        continue;
                    }
                    List<IIngredientGetter> remainingIngredients2 = Program.AllIngredients!.Skip(j).ToList();
                    IIngredientGetter[] potionRecipeList2 = getIngredientsMatchingTwoIngredients(ingredient, ingredient2, remainingIngredients2);
                    for (int m = 0; m < potionRecipeList2.Length; m++)
                    {
                        IIngredientGetter ingredient3 = potionRecipeList2[m];
                        IEnumerable<FormKey> formkeys = getEffectFormKeys(ingredient);
                        IEnumerable<FormKey> formkeys2 = getEffectFormKeys(ingredient2);
                        IEnumerable<FormKey> formkeys3 = getEffectFormKeys(ingredient3);
                        List<FormKey> formkeys1m = formkeys.Intersect(formkeys2).ToList();
                        List<FormKey> formkeys2m = formkeys3.Intersect(formkeys).ToList();
                        List<FormKey> formkeys3m = formkeys3.Intersect(formkeys2).ToList();
                        formkeys1m.AddRange(formkeys2m);
                        formkeys1m.AddRange(formkeys3m);
                        formkeys = formkeys1m.AsEnumerable().Distinct();
                        FormKey[] formkeysA = formkeys.ToArray();
                        if (formkeysA.Length < 1)
                            continue;
                        string potionString = "<font face='$HandwrittenFont'><font size='26'>";
                        potionString = "-<b>" + (ingredient.Name + "<br></b>-<b>" + ingredient2.Name + "<br></b>-<b>" + ingredient3.Name + "</b>");
                        List<string?> mgeflist = new List<string?>();
                        List<string?> mgeflists = new List<string?>();
                        List<bool> mgeflistD = new List<bool>();
                        List<FormKey> baseEffectFormKeys = new List<FormKey>();
                        for (int n = 0; n < formkeysA.Length; n++)
                        {
                            baseEffectFormKeys.Add(formkeysA[n]);
                            state.LinkCache.TryResolve<IMagicEffectGetter>(formkeysA[n], out var mgeffect);
                            mgeflist.Add(mgeffect?.Name?.String);
                            mgeflists.AddRange(mgeffect?.Name?.String?.Split()!);
                            IReadOnlyList<IFormLink<IKeywordGetter>>? thisKeywords = mgeffect.Keywords;
                            if (mgeffect.Flags.HasFlag(MagicEffect.Flag.Detrimental) || mgeffect.Flags.HasFlag(MagicEffect.Flag.Hostile) && (thisKeywords?.Intersect(Program.BadKeywordsF!).Any() == true))
                                mgeflistD.Add(true);
                            else
                                mgeflistD.Add(false);
                        }
                        string prefix = "Potion";
                        int type = 0;
                        if (mgeflistD.All(x => x.Equals(true)))
                        {
                            prefix = "Poison";
                            type = 1;
                            if (mgeflist.Count <= Program.Config?.PoisonSkipThreshold)
                                continue;
                            Program.OurMutex.WaitOne();
                            Program.PoisonRecipeCount++;
                            Program.OurMutex.ReleaseMutex();
                        }
                        else if (mgeflistD.Contains(true))//Check if effects match poison and potion
                        {
                            prefix = "Impure Potion";
                            type = 2;
                            if (mgeflist.Count <= Program.Config?.ImpureSkipThreshold)
                                continue;
                            Program.OurMutex.WaitOne();
                            Program.ImpurepotionRecipeCount++;
                            Program.OurMutex.ReleaseMutex();
                        }
                        else
                        {
                            if (mgeflist.Count <= Program.Config?.PotionSkipThreshold)
                                continue;
                            Program.OurMutex.WaitOne();
                            Program.PotionRecipeCount++;
                            Program.OurMutex.ReleaseMutex();
                        }
                        potionString += "</font><font face='$HandwrittenFont'><font size='26'><br> to make " + prefix + " of: <br></font><font face='$HandwrittenFont'><font size='26'>";
                        string potionName = "Recipe: ";
                        for (int k = 0; k < mgeflist.Count; k++)
                        {
                            if (k > 0)
                            {
                                potionName += " and ";
                                potionString += "<br>";
                            }
                            potionName += mgeflist[k];
                            potionString += mgeflist[k];
                        }
                        string sstring = "";

                        if (mgeflist.Count > 1)
                            sstring = "s";
                        potionString += "<br></font><font size='14'> Contains " + mgeflist.Count + " Effect" + sstring;
                        potionString += "<\\font>";
                        IIngredientGetter[] ingrss = { ingredient, ingredient2, ingredient3 };
                        Program.OurMutex.WaitOne();
                        IngredientCombination ingrcombo = new IngredientCombination(potionName, ingrss, mgeflist?.ToArray()!, baseEffectFormKeys.ToArray(), potionString, type);
                        Program.Combinations.Add(ingrcombo);
                        Program.OurMutex.ReleaseMutex();
                    }
                    j++;
                }
                i++;
                Program.OurMutex.WaitOne();
                Program.TotalProcessedCount++;
                if (Program.TotalIngredientCount <= Program.TotalProcessedCount)
                    Program.FinishedProcessing = true;
                Program.OurMutex.ReleaseMutex();
            }
        }
        private static IIngredientGetter[] getIngredientsMatchingOneIngredient(IIngredientGetter firstIngredient, IEnumerable<IIngredientGetter> otherIngredients)
        {
            List<IEffectGetter> firstIngredientEffects = firstIngredient.Effects.ToList();
            return (from matchingEffects in otherIngredients.ToList() where (firstIngredientEffects.Intersect(matchingEffects.Effects.ToList()).Any()) && (!firstIngredient.FormKey.Equals(matchingEffects.FormKey)) select matchingEffects).ToArray();

        }

        private static IIngredientGetter[] getIngredientsMatchingTwoIngredients(IIngredientGetter firstIngredient, IIngredientGetter secondIngredient, IEnumerable<IIngredientGetter> otherIngredients)
        {
            List<IEffectGetter> firstIngredientEffects = firstIngredient.Effects.ToList();
            List<IEffectGetter> secondIngredientEffects = secondIngredient.Effects.ToList();
            return (from matchingEffects in otherIngredients.ToList() where ((firstIngredientEffects.Intersect(matchingEffects.Effects).Any() || firstIngredientEffects.Intersect(secondIngredientEffects).Any()) && (secondIngredientEffects.Intersect(matchingEffects.Effects).Any() || secondIngredientEffects.Intersect(matchingEffects.Effects).Any())  && (!firstIngredient.FormKey.Equals(matchingEffects.FormKey) && !secondIngredient.FormKey.Equals(matchingEffects.FormKey) && !firstIngredient.FormKey.Equals(secondIngredient.FormKey))) select matchingEffects).ToArray();
        }

        //private IIngredientGetter[] getIngredientsMatchingOneIngredient(IIngredientGetter firstIngredient, IEnumerable<IIngredientGetter> otherIngredients)
        //{
        //    return (from matchingIngredient in otherIngredients.ToList() where (firstIngredient.Effects.Intersect(matchingIngredient.Effects.ToList()).Any()) && (!firstIngredient.FormKey.Equals(matchingIngredient.FormKey)) select matchingIngredient).ToArray();
        //    //List<FormKey> firstIngredientEffectKeys = getEffectFormKeys(firstIngredient);
        //    //List<IIngredientGetter> otherIngredientsL = (from otherIngredient in otherIngredients where !firstIngredient.FormKey.Equals(otherIngredient.FormKey) select otherIngredient).ToList();
        //    //List<IIngredientGetter> otherIngredientsLR = otherIngredientsL;
        //    //for (int i = 0; i < otherIngredientsL.Count; i++)
        //    //{
        //    //    IIngredientGetter otherIngredient = otherIngredientsL.ElementAt(i);
        //    //    List<FormKey> otherIngredientEffectKeys = getEffectFormKeys(otherIngredient);
        //    //    if (!otherIngredientEffectKeys.Intersect(firstIngredientEffectKeys).Any())
        //    //        otherIngredientsLR.Remove(otherIngredient);
        //    //}
        //    //return otherIngredientsLR.ToArray();
        //}
        //private IIngredientGetter[] getIngredientsMatchingTwoIngredients(IIngredientGetter firstIngredient, IIngredientGetter secondIngredient, IEnumerable<IIngredientGetter> otherIngredients)
        //{

        //    return (from matchingIngredient in otherIngredients where (firstIngredient.Effects.Intersect(secondIngredient.Effects).Any() || firstIngredient.Effects.Intersect(matchingIngredient.Effects).Any()) && (secondIngredient.Effects.Intersect(firstIngredient.Effects).Any() || secondIngredient.Effects.Intersect(matchingIngredient.Effects).Any()) && (matchingIngredient.Effects.Intersect(firstIngredient.Effects).Any() || matchingIngredient.Effects.Intersect(secondIngredient.Effects).Any()) && (!firstIngredient.FormKey.Equals(secondIngredient.FormKey)) && (!secondIngredient.FormKey.Equals(matchingIngredient.FormKey)) && (!firstIngredient.FormKey.Equals(matchingIngredient.FormKey)) select matchingIngredient).ToArray();
        //    //List<FormKey> firstIngredientEffectKeys = getEffectFormKeys(firstIngredient);
        //    //List<FormKey> secondIngredientEffectKeys = getEffectFormKeys(secondIngredient);
        //    //firstIngredientEffectKeys.AddRange(secondIngredientEffectKeys);
        //    //firstIngredientEffectKeys = firstIngredientEffectKeys.AsEnumerable().Distinct().ToList();
        //    //List<IIngredientGetter> otherIngredientsL = (from otherIngredient in otherIngredients where !firstIngredient.FormKey.Equals(secondIngredient.FormKey) && !firstIngredient.FormKey.Equals(otherIngredient.FormKey) && !secondIngredient.FormKey.Equals(otherIngredient.FormKey) select otherIngredient).ToList();
        //    //List<IIngredientGetter> otherIngredientsLR = otherIngredientsL;
        //    //for (int i = 0; i < otherIngredientsL.Count; i++)
        //    //{
        //    //    IIngredientGetter otherIngredient = otherIngredientsL.ElementAt(i);
        //    //    List<FormKey> otherIngredientEffectKeys = getEffectFormKeys(otherIngredient);
        //    //    if (!otherIngredientEffectKeys.Intersect(firstIngredientEffectKeys).Any())
        //    //        otherIngredientsLR.Remove(otherIngredient);
        //    //}
        //    //return otherIngredientsLR.ToArray();
        //}
        private List<FormKey> getEffectFormKeys(IIngredientGetter ingredient)
        {
            List<FormKey> formkeys = new List<FormKey>();
            foreach (IEffectGetter effect in ingredient.Effects)
                formkeys.Add(effect.BaseEffect.FormKey);
            return formkeys;
        }
    }
}
static class Extensions
{
    public static IEnumerable<IEnumerable<IIngredientGetter>> Partition<IIngredientGetter>(this IEnumerable<IIngredientGetter> items, int partitionSize)
    {
        return new PartitionHelper<IIngredientGetter>(items, partitionSize);
    }
    private sealed class PartitionHelper<IIngredientGetter> : IEnumerable<IEnumerable<IIngredientGetter>>
    {
        readonly IEnumerable<IIngredientGetter> items;
        readonly int partitionSize;
        bool hasMoreItems;

        internal PartitionHelper(IEnumerable<IIngredientGetter> i, int ps)
        {
            items = i;
            partitionSize = ps;
        }

        public IEnumerator<IEnumerable<IIngredientGetter>> GetEnumerator()
        {
            using (var enumerator = items.GetEnumerator())
            {
                hasMoreItems = enumerator.MoveNext();
                while (hasMoreItems)
                    yield return GetNextBatch(enumerator).ToList();
            }
        }

        IEnumerable<IIngredientGetter> GetNextBatch(IEnumerator<IIngredientGetter> enumerator)
        {
            for (int i = 0; i < partitionSize; ++i)
            {
                yield return enumerator.Current;
                hasMoreItems = enumerator.MoveNext();
                if (!hasMoreItems)
                    yield break;
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}